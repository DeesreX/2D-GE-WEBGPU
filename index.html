<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 2D Game Engine with Multiple Views</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            background-color: #2b2b2b;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            display: flex;
            flex-direction: row;
        }

        .panel {
            border: 1px solid #555;
            box-sizing: border-box;
            padding: 10px;
        }

        #gameCanvas {
            flex: 3;
            background: #1e1e1e;
            image-rendering: pixelated;
        }

        #objectPanel {
            flex: 1;
            background: #2e2e2e;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .object {
            background: #4e4e4e;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
            width: 80%;
            text-align: center;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600" class="panel"></canvas>
    <div id="objectPanel" class="panel">
        <h3>Objects</h3>
        <div class="object" onclick="addObject('Tree')">Tree</div>
        <div class="object" onclick="addObject('Rock')">Rock</div>
        <div class="object" onclick="addObject('House')">House</div>
        <div class="object" onclick="addObject('NPC')">NPC</div>
    </div>
    <script type="module">
        async function initializeWebGPU() {
            if (!navigator.gpu) {
                console.error("WebGPU is not supported on this browser.");
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                console.error("Failed to get GPU adapter.");
                return;
            }

            const device = await adapter.requestDevice();
            const canvas = document.getElementById("gameCanvas");
            const context = canvas.getContext("webgpu");

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: format,
                alphaMode: "opaque"
            });

            return { device, context, format };
        }

        let lastTime = 0;
        let tileSize;
        const gameState = {
            player: { x: 50, y: 50, speed: 100 },
            keysPressed: {},
            tileMap: [],
            objects: []
        };

        // Initialize Tile Map
        function initializeTileMap(mapWidth, mapHeight) {
            gameState.tileMap = [];
            for (let y = 0; y < mapHeight; y++) {
                gameState.tileMap[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    // Example: Randomly assign tile types (0: ground, 1: wall)
                    gameState.tileMap[y][x] = Math.random() > 0.8 ? 1 : 0;
                }
            }
        }

        function resetGame() {
            gameState.player.x = 50;
            gameState.player.y = 50;
        }

        // Add an object to the map
        function addObject(type) {
            // Example: add the object at a random location
            const x = Math.floor(Math.random() * 20);
            const y = Math.floor(Math.random() * 15);
            gameState.objects.push({ type, x, y });
            console.log(`Added ${type} at (${x}, ${y})`);
        }

        // Input Handling
        window.addEventListener("keydown", (e) => {
            gameState.keysPressed[e.key] = true;
        });

        window.addEventListener("keyup", (e) => {
            delete gameState.keysPressed[e.key];
        });

        async function gameLoop(device, context, format, timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Start Loop: Record current time to calculate delta time
            update(deltaTime);

            // Physics Calculation: Handle collision detection and responses
            handlePhysics();

            render(device, context, format);

            // End Loop: Calculate time for the next frame
            requestAnimationFrame((t) => gameLoop(device, context, format, t));
        }

        // Update Function
        function update(deltaTime) {
            const player = gameState.player;
            if (gameState.keysPressed["ArrowUp"]) player.y -= player.speed * deltaTime;
            if (gameState.keysPressed["ArrowDown"]) player.y += player.speed * deltaTime;
            if (gameState.keysPressed["ArrowLeft"]) player.x -= player.speed * deltaTime;
            if (gameState.keysPressed["ArrowRight"]) player.x += player.speed * deltaTime;

            // Keep the player within the canvas boundaries
            const canvas = document.getElementById("gameCanvas");
            player.x = Math.max(0, Math.min(canvas.width - tileSize, player.x));
            player.y = Math.max(0, Math.min(canvas.height - tileSize, player.y));
        }

        // Handle Physics
        function handlePhysics() {
            // Example placeholder for collision detection and response
            // Currently, there's no other entity to collide with, but this function can be expanded
        }

        // Render Function
        function render(device, context, format) {
            const encoder = device.createCommandEncoder();

            const textureView = context.getCurrentTexture().createView();
            const renderPassDescriptor = {
                colorAttachments: [
                    {
                        view: textureView,
                        clearValue: { r: 0.15, g: 0.15, b: 0.15, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }
                ]
            };

            const passEncoder = encoder.beginRenderPass(renderPassDescriptor);

            // Render the tile map
            const canvas = document.getElementById("gameCanvas");
            const mapWidth = gameState.tileMap[0].length;
            const mapHeight = gameState.tileMap.length;
            tileSize = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);

            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const tile = gameState.tileMap[y][x];
                    const tileColor = tile === 1 ? { r: 0.3, g: 0.3, b: 0.3, a: 1.0 } : { r: 0.8, g: 0.9, b: 0.8, a: 1.0 };

                    passEncoder.setPipeline(createTilePipeline(device, tileColor));
                    passEncoder.setViewport(Math.floor(x * tileSize), Math.floor(y * tileSize), Math.floor(tileSize), Math.floor(tileSize), 0, 1);
                    passEncoder.draw(6, 1, 0, 0);
                }
            }

            // Render objects on the map
            gameState.objects.forEach((obj) => {
                const objColor = { r: 0.5, g: 0.2, b: 0.7, a: 1.0 }; // Example color for all objects
                passEncoder.setPipeline(createTilePipeline(device, objColor));
                passEncoder.setViewport(Math.floor(obj.x * tileSize), Math.floor(obj.y * tileSize), Math.floor(tileSize), Math.floor(tileSize), 0, 1);
                passEncoder.draw(6, 1, 0, 0);
            });

            passEncoder.end();

            device.queue.submit([encoder.finish()]);
        }

        function createTilePipeline(device, color) {
            const shaderModule = device.createShaderModule({
                code: `
                    @vertex
                    fn vertex_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
                        var positions = array<vec2<f32>, 6>(
                            vec2<f32>(0.0, 0.0),
                            vec2<f32>(1.0, 0.0),
                            vec2<f32>(0.0, 1.0),
                            vec2<f32>(0.0, 1.0),
                            vec2<f32>(1.0, 0.0),
                            vec2<f32>(1.0, 1.0)
                        );
                        let pos = positions[vertexIndex];
                        return vec4<f32>(pos * 2.0 - 1.0, 0.0, 1.0);
                    }

                    @fragment
                    fn fragment_main() -> @location(0) vec4<f32> {
                        return vec4<f32>(${color.r}, ${color.g}, ${color.b}, ${color.a});
                    }
                `
            });

            const pipeline = device.createRenderPipeline({
                layout: "auto",
                vertex: {
                    module: shaderModule,
                    entryPoint: "vertex_main"
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: "fragment_main",
                    targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }]
                },
                primitive: {
                    topology: "triangle-list"
                }
            });

            return pipeline;
        }

        // Initialize WebGPU and start game loop
        initializeWebGPU().then(({ device, context, format }) => {
            if (device && context && format) {
                const canvas = document.getElementById("gameCanvas");
                const mapWidth = 20;
                const mapHeight = 15;
                initializeTileMap(mapWidth, mapHeight);
                requestAnimationFrame((t) => gameLoop(device, context, format, t));
            }
        });
    </script>
</body>
</html>